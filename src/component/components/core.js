// Generated by CoffeeScript 1.4.0
(function() {

  define([], function() {
    var Diode;
    return Diode = (function() {
      var Inductor;

      function Diode() {
        this.nodes = new Array(2);
        this.vt = 0;
        this.vdcoef = 0;
        this.fwdrop = 0;
        this.zvoltage = 0;
        this.zoffset = 0;
        this.lastvoltdiff = 0;
        this.crit = 0;
      }

      Diode.prototype.leakage = 1e-14;

      Diode.prototype.setup = function(fw, zv) {
        var i;
        this.fwdrop = fw;
        this.zvoltage = zv;
        this.vdcoef = Math.log(1 / this.leakage + 1) / this.fwdrop;
        this.vt = 1 / this.vdcoef;
        this.vcrit = this.vt * Math.log(this.vt / (Math.sqrt(2) * this.leakage));
        if (this.zvoltage !== 0) {
          i = -.005;
          return this.zoffset = this.zvoltage - Math.log(-(1 + i / this.leakage)) / this.vdcoef;
        }
      };

      Diode.prototype.reset = function() {
        return this.lastvoltdiff = 0;
      };

      Diode.prototype.limitStep = function(vnew, vold) {
        var arg, oo, v0;
        arg = void 0;
        oo = vnew;
        if (vnew > this.vcrit && Math.abs(vnew - vold) > (this.vt + this.vt)) {
          if (vold > 0) {
            arg = 1 + (vnew - vold) / this.vt;
            if (arg > 0) {
              vnew = vold + this.vt * Math.log(arg);
              v0 = Math.log(1e-6 / this.leakage) * this.vt;
              vnew = Math.max(v0, vnew);
            } else {
              vnew = this.vcrit;
            }
          } else {
            vnew = this.vt * Math.log(vnew / this.vt);
          }
          Circuit.converged = false;
        } else if (vnew < 0 && this.zoffset !== 0) {
          vnew = -vnew - this.zoffset;
          vold = -vold - this.zoffset;
          if (vnew > this.vcrit && Math.abs(vnew - vold) > (this.vt + this.vt)) {
            if (vold > 0) {
              arg = 1 + (vnew - vold) / this.vt;
              if (arg > 0) {
                vnew = vold + this.vt * Math.log(arg);
                v0 = Math.log(1e-6 / this.leakage) * this.vt;
                vnew = Math.max(v0, vnew);
              } else {
                vnew = this.vcrit;
              }
            } else {
              vnew = this.vt * Math.log(vnew / this.vt);
            }
            Circuit.converged = false;
          }
          vnew = -(vnew + this.zoffset);
        }
        return vnew;
      };

      Diode.prototype.stamp = function(n0, n1) {
        this.nodes[0] = n0;
        this.nodes[1] = n1;
        Circuit.stampNonLinear(this.nodes[0]);
        return Circuit.stampNonLinear(this.nodes[1]);
      };

      Diode.prototype.doStep = function(voltdiff) {
        var eval_, geq, nc;
        if (Math.abs(voltdiff - Circuit.lastvoltdiff) > .01) {
          Circuit.converged = false;
        }
        voltdiff = this.limitStep(voltdiff, Circuit.lastvoltdiff);
        Circuit.lastvoltdiff = voltdiff;
        if (voltdiff >= 0 || this.zvoltage === 0) {
          eval_ = Math.exp(voltdiff * this.vdcoef);
          if (voltdiff < 0) {
            eval_ = 1;
          }
          geq = this.vdcoef * this.leakage * eval_;
          nc = (eval_ - 1) * this.leakage - geq * voltdiff;
          Circuit.stampConductance(this.nodes[0], this.nodes[1], geq);
          return Circuit.stampCurrentSource(this.nodes[0], this.nodes[1], nc);
        } else {
          geq = this.leakage * this.vdcoef * (Math.exp(voltdiff * this.vdcoef) + Math.exp((-voltdiff - this.zoffset) * this.vdcoef));
          nc = this.leakage * (Math.exp(voltdiff * this.vdcoef) - Math.exp((-voltdiff - this.zoffset) * this.vdcoef) - 1) + geq * (-voltdiff);
          Circuit.stampConductance(this.nodes[0], this.nodes[1], geq);
          return Circuit.stampCurrentSource(this.nodes[0], this.nodes[1], nc);
        }
      };

      Diode.prototype.calculateCurrent = function(voltdiff) {
        if (voltdiff >= 0 || this.zvoltage === 0) {
          return this.leakage * (Math.exp(voltdiff * this.vdcoef) - 1);
        }
        return this.leakage * (Math.exp(voltdiff * this.vdcoef) - Math.exp((-voltdiff - this.zoffset) * this.vdcoef) - 1);
      };

      Inductor = function() {
        this.nodes = new Array(2);
        this.flags = 0;
        this.inductance = 0;
        this.compResistance = 0;
        this.current = 0;
        return this.curSourceValue = 0;
      };

      Inductor.FLAG_BACK_EULER = 2;

      Inductor.prototype.setup = function(ic, cr, f) {
        this.inductance = ic;
        this.current = cr;
        return this.flags = f;
      };

      Inductor.prototype.isTrapezoidal = function() {
        return (this.flags & Inductor.FLAG_BACK_EULER) === 0;
      };

      Inductor.prototype.reset = function() {
        return this.current = 0;
      };

      Inductor.prototype.stamp = function(n0, n1) {
        this.nodes[0] = n0;
        this.nodes[1] = n1;
        if (this.isTrapezoidal()) {
          this.compResistance = 2 * this.inductance / Circuit.timeStep;
        } else {
          this.compResistance = this.inductance / Circuit.timeStep;
        }
        Circuit.stampResistor(this.nodes[0], this.nodes[1], this.compResistance);
        Circuit.stampRightSide(this.nodes[0]);
        return Circuit.stampRightSide(this.nodes[1]);
      };

      Inductor.prototype.nonLinear = function() {
        return false;
      };

      Inductor.prototype.startIteration = function(voltdiff) {
        if (this.isTrapezoidal()) {
          return this.curSourceValue = voltdiff / this.compResistance + this.current;
        } else {
          return this.curSourceValue = this.current;
        }
      };

      Inductor.prototype.calculateCurrent = function(voltdiff) {
        if (this.compResistance > 0) {
          this.current = voltdiff / this.compResistance + this.curSourceValue;
        }
        return this.current;
      };

      Inductor.prototype.doStep = function(voltdiff) {
        return Circuit.stampCurrentSource(this.nodes[0], this.nodes[1], this.curSourceValue);
      };

      return Diode;

    })();
  });

}).call(this);
