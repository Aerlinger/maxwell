// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['cs!Settings', 'cs!DrawHelper', 'cs!Polygon', 'cs!Rectangle', 'cs!Point', 'cs!CircuitComponent', 'cs!Units'], function(Settings, DrawHelper, Polygon, Rectangle, Point, CircuitComponent, Units) {
    var MosfetElm;
    MosfetElm = (function(_super) {

      __extends(MosfetElm, _super);

      MosfetElm.FLAG_PNP = 1;

      MosfetElm.FLAG_SHOWVT = 2;

      MosfetElm.FLAG_DIGITAL = 4;

      function MosfetElm(xa, ya, xb, yb, f, st) {
        MosfetElm.__super__.constructor.call(this, xa, ya, xb, yb, f);
        this.lastv1 = 0;
        this.lastv2 = 0;
        this.ids = 0;
        this.mode = 0;
        this.gm = 0;
        this.vt = 1.5;
        this.pcircler;
        this.src = [];
        this.drn = [];
        this.gate = [];
        this.pcircle = [];
        this.pnp = ((f & MosfetElm.FLAG_PNP) !== 0 ? -1 : 1);
        this.noDiagonal = true;
        this.vt = this.getDefaultThreshold();
        this.hs = 16;
        try {
          if (st && st.length > 0) {
            if (typeof st === "string") {
              st = st.split(" ");
            }
            this.vt = st[0];
          }
        } catch (_error) {}
      }

      MosfetElm.prototype.getDefaultThreshold = function() {
        return 1.5;
      };

      MosfetElm.prototype.getBeta = function() {
        return .02;
      };

      MosfetElm.prototype.nonLinear = function() {
        return true;
      };

      MosfetElm.prototype.drawDigital = function() {
        return (this.flags & MosfetElm.FLAG_DIGITAL) !== 0;
      };

      MosfetElm.prototype.reset = function() {
        return this.lastv1 = this.lastv2 = this.volts[0] = this.volts[1] = this.volts[2] = this.curcount = 0;
      };

      MosfetElm.prototype.dump = function() {
        return CircuitComponent.prototype.dump.call(this) + " " + this.vt;
      };

      MosfetElm.prototype.getDumpType = function() {
        return "f";
      };

      MosfetElm.prototype.draw = function() {
        var color, ds, i, s, segf, segments, v;
        this.setBboxPt(this.point1, this.point2, this.hs);
        color = this.setVoltageColor(this.volts[1]);
        CircuitComponent.drawThickLinePt(this.src[0], this.src[1], color);
        color = this.setVoltageColor(this.volts[2]);
        CircuitComponent.drawThickLinePt(this.drn[0], this.drn[1], color);
        segments = 6;
        i = void 0;
        this.setPowerColor(true);
        segf = 1.0 / segments;
        i = 0;
        while (i !== segments) {
          v = this.volts[1] + (this.volts[2] - this.volts[1]) * i / segments;
          color = this.setVoltageColor(v);
          DrawHelper.interpPoint(this.src[1], this.drn[1], CircuitComponent.ps1, i * segf);
          DrawHelper.interpPoint(this.src[1], this.drn[1], CircuitComponent.ps2, (i + 1) * segf);
          CircuitComponent.drawThickLinePt(CircuitComponent.ps1, CircuitComponent.ps2, color);
          i++;
        }
        color = this.setVoltageColor(this.volts[1]);
        CircuitComponent.drawThickLinePt(this.src[1], this.src[2], color);
        color = this.setVoltageColor(this.volts[2]);
        CircuitComponent.drawThickLinePt(this.drn[1], this.drn[2], color);
        if (!this.drawDigital()) {
          color = this.setVoltageColor((this.pnp === 1 ? this.volts[1] : this.volts[2]));
          CircuitComponent.drawThickPolygonP(this.arrowPoly, color);
        }
        Circuit.powerCheckItem;
        color = this.setVoltageColor(this.volts[0]);
        CircuitComponent.drawThickLinePt(this.point1, this.gate[1], color);
        CircuitComponent.drawThickLinePt(this.gate[0], this.gate[2], color);
        this.drawDigital() && this.pnp === -1;
        if ((this.flags & MosfetElm.FLAG_SHOWVT) !== 0) {
          s = "" + (this.vt * this.pnp);
          this.drawCenteredText(s, this.x2 + 2, this.y2, false);
        }
        if ((this.needsHighlight() || Circuit.dragElm === this) && this.dy === 0) {
          ds = MathUtils.sign(this.dx);
        }
        this.curcount = this.updateDotCount(-this.ids, this.curcount);
        this.drawDots(this.src[0], this.src[1], this.curcount);
        this.drawDots(this.src[1], this.drn[1], this.curcount);
        this.drawDots(this.drn[1], this.drn[0], this.curcount);
        return this.drawPosts();
      };

      MosfetElm.prototype.getPost = function(n) {
        if (n === 0) {
          return this.point1;
        } else {
          if (n === 1) {
            return this.src[0];
          } else {
            return this.drn[0];
          }
        }
      };

      MosfetElm.prototype.getCurrent = function() {
        return this.ids;
      };

      MosfetElm.prototype.getPower = function() {
        return this.ids * (this.volts[2] - this.volts[1]);
      };

      MosfetElm.prototype.getPostCount = function() {
        return 3;
      };

      MosfetElm.prototype.setPoints = function() {
        var dist, hs2;
        CircuitComponent.prototype.setPoints.call(this);
        hs2 = this.hs * this.dsign;
        this.src = CircuitComponent.newPointArray(3);
        this.drn = CircuitComponent.newPointArray(3);
        DrawHelper.interpPoint(this.point1, this.point2, 1, -hs2, this.src[0], this.drn[0]);
        DrawHelper.interpPoint(this.point1, this.point2, 1 - 22 / this.dn, -hs2, this.src[1], this.drn[1]);
        DrawHelper.interpPoint(this.point1, this.point2, 1 - 22 / this.dn, -hs2 * 4 / 3, this.src[2], this.drn[2]);
        this.gate = CircuitComponent.newPointArray(3);
        DrawHelper.interpPoint(this.point1, this.point2, 1 - 28 / this.dn, hs2 / 2, this.gate[0], this.gate[2]);
        DrawHelper.interpPoint(this.gate[0], this.gate[2], this.gate[1], .5);
        if (!this.drawDigital()) {
          if (this.pnp === 1) {
            return this.arrowPoly = DrawHelper.calcArrow(this.src[1], this.src[0], 10, 4);
          } else {
            return this.arrowPoly = DrawHelper.calcArrow(this.drn[0], this.drn[1], 12, 5);
          }
        } else if (this.pnp === -1) {
          DrawHelper.interpPoint(this.point1, this.point2, this.gate[1], 1 - 36 / this.dn);
          dist = (this.dsign < 0 ? 32 : 31);
          this.pcircle = this.interpPoint(this.point1, this.point2, 1 - dist / this.dn);
          return this.pcircler = 3;
        }
      };

      MosfetElm.prototype.stamp = function() {
        Circuit.stampNonLinear(this.nodes[1]);
        return Circuit.stampNonLinear(this.nodes[2]);
      };

      MosfetElm.prototype.doStep = function() {
        var Gds, beta, drain, gate, realvds, realvgs, rs, source, vds, vgs, vs;
        vs = new Array(3);
        vs[0] = this.volts[0];
        vs[1] = this.volts[1];
        vs[2] = this.volts[2];
        if (vs[1] > this.lastv1 + .5) {
          vs[1] = this.lastv1 + .5;
        }
        if (vs[1] < this.lastv1 - .5) {
          vs[1] = this.lastv1 - .5;
        }
        if (vs[2] > this.lastv2 + .5) {
          vs[2] = this.lastv2 + .5;
        }
        if (vs[2] < this.lastv2 - .5) {
          vs[2] = this.lastv2 - .5;
        }
        source = 1;
        drain = 2;
        if (this.pnp * vs[1] > this.pnp * vs[2]) {
          source = 2;
          drain = 1;
        }
        gate = 0;
        vgs = vs[gate] - vs[source];
        vds = vs[drain] - vs[source];
        if (Math.abs(this.lastv1 - vs[1]) > .01 || Math.abs(this.lastv2 - vs[2]) > .01) {
          Circuit.converged = false;
        }
        this.lastv1 = vs[1];
        this.lastv2 = vs[2];
        realvgs = vgs;
        realvds = vds;
        vgs *= this.pnp;
        vds *= this.pnp;
        this.ids = 0;
        this.gm = 0;
        Gds = 0;
        beta = this.getBeta();
        if (vgs > .5 && this instanceof JFetElm) {
          Circuit.halt("JFET is reverse biased!", this);
          return;
        }
        if (vgs < this.vt) {
          Gds = 1e-8;
          this.ids = vds * Gds;
          this.mode = 0;
        } else if (vds < vgs - this.vt) {
          this.ids = beta * ((vgs - this.vt) * vds - vds * vds * .5);
          this.gm = beta * vds;
          Gds = beta * (vgs - vds - this.vt);
          this.mode = 1;
        } else {
          this.gm = beta * (vgs - this.vt);
          Gds = 1e-8;
          this.ids = .5 * beta * (vgs - this.vt) * (vgs - this.vt) + (vds - (vgs - this.vt)) * Gds;
          this.mode = 2;
        }
        rs = -this.pnp * this.ids + Gds * realvds + this.gm * realvgs;
        Circuit.stampMatrix(this.nodes[drain], this.nodes[drain], Gds);
        Circuit.stampMatrix(this.nodes[drain], this.nodes[source], -Gds - this.gm);
        Circuit.stampMatrix(this.nodes[drain], this.nodes[gate], this.gm);
        Circuit.stampMatrix(this.nodes[source], this.nodes[drain], -Gds);
        Circuit.stampMatrix(this.nodes[source], this.nodes[source], Gds + this.gm);
        Circuit.stampMatrix(this.nodes[source], this.nodes[gate], -this.gm);
        Circuit.stampRightSide(this.nodes[drain], rs);
        Circuit.stampRightSide(this.nodes[source], -rs);
        if (source === 2 && this.pnp === 1 || source === 1 && this.pnp === -1) {
          return this.ids = -this.ids;
        }
      };

      MosfetElm.prototype.getFetInfo = function(arr, n) {
        arr[0] = (this.pnp === -1 ? "p-" : "n-") + n;
        arr[0] += " (Vt = " + CircuitComponent.getVoltageText(this.pnp * this.vt) + ")";
        arr[1] = (this.pnp === 1 ? "Ids = " : "Isd = ") + CircuitComponent.getCurrentText(this.ids);
        arr[2] = "Vgs = " + CircuitComponent.getVoltageText(this.volts[0] - this.volts[(this.pnp === -1 ? 2 : 1)]);
        arr[3] = (this.pnp === 1 ? "Vds = " : "Vsd = ") + CircuitComponent.getVoltageText(this.volts[2] - this.volts[1]);
        arr[4] = (this.mode === 0 ? "off" : (this.mode === 1 ? "linear" : "saturation"));
        return arr[5] = "gm = " + CircuitComponent.getUnitText(this.gm, "A/V");
      };

      MosfetElm.prototype.getInfo = function(arr) {
        return this.getFetInfo(arr, "MOSFET");
      };

      MosfetElm.prototype.canViewInScope = function() {
        return true;
      };

      MosfetElm.prototype.getVoltageDiff = function() {
        return this.volts[2] - this.volts[1];
      };

      MosfetElm.prototype.getConnection = function(n1, n2) {
        return !(n1 === 0 || n2 === 0);
      };

      MosfetElm.prototype.getEditInfo = function(n) {
        var ei;
        if (n === 0) {
          return new EditInfo("Threshold Voltage", this.pnp * this.vt, .01, 5);
        }
        if (n === 1) {
          ei = new EditInfo("", 0, -1, -1);
          ei.checkbox = "Digital Symbol";
          return ei;
        }
        return null;
      };

      MosfetElm.prototype.setEditValue = function(n, ei) {
        if (n === 0) {
          this.vt = this.pnp * ei.value;
        }
        if (n === 1) {
          this.flags = (ei.checkbox ? this.flags | MosfetElm.FLAG_DIGITAL : this.flags & ~MosfetElm.FLAG_DIGITAL);
          return this.setPoints();
        }
      };

      return MosfetElm;

    })(TransistorElm);
    return MosfetElm;
  });

}).call(this);
