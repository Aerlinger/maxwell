// Generated by CoffeeScript 1.10.0
(function() {
  var CapacitorElm, CircuitNode, CircuitNodeLink, CircuitSolver, CurrentElm, GroundElm, InductorElm, MatrixStamper, Pathfinder, RailElm, RowInfo, Setting, SimulationFrame, Util, VoltageElm, WireElm;

  MatrixStamper = require('./MatrixStamper.js');

  Pathfinder = require('./Pathfinder.js');

  CircuitNode = require('./CircuitNode.js');

  CircuitNodeLink = require('./CircuitNodeLink.js');

  RowInfo = require('./RowInfo.js');

  Setting = require('../Settings.js');

  Util = require('../util/Util.js');

  SimulationFrame = require('../circuit/SimulationFrame.js');

  GroundElm = require('../components/GroundElm.js');

  RailElm = require('../components/RailElm.js');

  VoltageElm = require('../components/VoltageElm.js');

  WireElm = require('../components/WireElm.js');

  CapacitorElm = require('../components/CapacitorElm.js');

  InductorElm = require('../components/InductorElm.js');

  CurrentElm = require('../components/CurrentElm.js');

  CircuitSolver = (function() {
    CircuitSolver.SIZE_LIMIT = 100;

    CircuitSolver.MAXIMUM_SUBITERATIONS = 5000;

    function CircuitSolver(Circuit) {
      this.Circuit = Circuit;
      this.scaleFactors = Util.zeroArray(400);
      this.reset();
      this.Stamper = new MatrixStamper(this.Circuit);
    }

    CircuitSolver.prototype.reset = function() {
      this.Circuit.time = 0;
      this.iterations = 0;
      this.converged = true;
      this.subIterations = 5000;
      this.circuitMatrix = [];
      this.circuitRightSide = [];
      this.origMatrix = [];
      this.origRightSide = [];
      this.circuitRowInfo = [];
      this.circuitPermute = [];
      this.circuitNonLinear = false;
      this.lastTime = 0;
      this.secTime = 0;
      this.lastFrameTime = 0;
      this.lastIterTime = 0;
      this.analyzeFlag = true;
      return this.simulationFrames = [];
    };

    CircuitSolver.prototype.reconstruct = function() {
      if (!this.analyzeFlag || (this.Circuit.numElements() === 0)) {
        return;
      }
      this.Circuit.clearErrors();
      this.Circuit.resetNodes();
      this.discoverGroundReference();
      this.constructCircuitGraph();
      this.constructMatrixEquations();
      this.checkConnectivity();
      this.findInvalidPaths();
      this.optimize();
      if (this.circuitLinear()) {
        return this.luFactor(this.circuitMatrix, this.circuitMatrixSize, this.circuitPermute);
      }
    };

    CircuitSolver.prototype.solveCircuit = function() {
      var circuitElm, iter, j, l, len, len1, len2, lit, m, n, o, p, ref, ref1, ref2, ref3, ref4, res, scope, stepRate, subiter, tm;
      if ((this.circuitMatrix == null) || this.Circuit.numElements() === 0) {
        this.circuitMatrix = null;
        return;
      }
      this.sysTime = (new Date()).getTime();
      stepRate = Math.floor(160 * this.getIterCount());
      tm = (new Date()).getTime();
      lit = this.lastIterTime;
      if (1000 >= (stepRate * (tm - this.lastIterTime))) {
        return;
      }
      iter = 1;
      while (true) {
        ++this.steps;
        ref = this.Circuit.getElements();
        for (l = 0, len = ref.length; l < len; l++) {
          circuitElm = ref[l];
          circuitElm.startIteration();
        }
        for (subiter = m = 0, ref1 = CircuitSolver.MAXIMUM_SUBITERATIONS; 0 <= ref1 ? m < ref1 : m > ref1; subiter = 0 <= ref1 ? ++m : --m) {
          this.converged = true;
          this.subIterations = subiter;
          this.restoreOriginalMatrixState();
          ref2 = this.Circuit.getElements();
          for (n = 0, len1 = ref2.length; n < len1; n++) {
            circuitElm = ref2[n];
            circuitElm.doStep(this.Stamper);
          }
          if (this.circuitNonLinear) {
            if (this.converged && subiter > 0) {
              break;
            }
            this.luFactor(this.circuitMatrix, this.circuitMatrixSize, this.circuitPermute);
          }
          this.luSolve(this.circuitMatrix, this.circuitMatrixSize, this.circuitPermute, this.circuitRightSide);
          for (j = o = 0, ref3 = this.circuitMatrixFullSize; 0 <= ref3 ? o < ref3 : o > ref3; j = 0 <= ref3 ? ++o : --o) {
            res = this.getValueFromNode(j);
            if (!this.updateComponent(j, res)) {
              break;
            }
          }
          if (this.circuitLinear()) {
            break;
          }
        }
        if (subiter >= CircuitSolver.MAXIMUM_SUBITERATIONS) {
          this.halt("Convergence failed: " + subiter, null);
          break;
        }
        this.Circuit.time += this.Circuit.timeStep();
        if ((iter + 20) % 21 === 0) {
          ref4 = this.Circuit.scopes;
          for (p = 0, len2 = ref4.length; p < len2; p++) {
            scope = ref4[p];
            if (scope.circuitElm) {
              scope.sampleVoltage(this.Circuit.time, scope.circuitElm.getVoltageDiff());
              scope.sampleCurrent(this.Circuit.time, scope.circuitElm.getCurrent());
            }
          }
        }
        tm = (new Date()).getTime();
        lit = tm;
        if ((tm - this.lastFrameTime) > 2000) {
          break;
        }
        if ((iter * 1000) >= (stepRate * (tm - this.lastIterTime))) {
          break;
        }
        ++iter;
      }
      this.frames++;
      this.Circuit.iterations++;
      this.simulationFrames.push(new SimulationFrame(this.Circuit));
      return this._updateTimings(lit);
    };

    CircuitSolver.prototype.circuitLinear = function() {
      return !this.circuitNonLinear;
    };

    CircuitSolver.prototype._updateTimings = function(lastIterationTime) {
      var currentSpeed, inc, sysTime;
      this.lastIterTime = lastIterationTime;
      sysTime = (new Date()).getTime();
      if (this.lastTime !== 0) {
        inc = Math.floor(sysTime - this.lastTime);
        currentSpeed = Math.exp(this.Circuit.currentSpeed() / 3.5 - 14.2);
        this.Circuit.Params.setCurrentMult(1.7 * inc * currentSpeed);
      }
      if ((sysTime - this.secTime) >= 1000) {
        this.frames = 0;
        this.steps = 0;
        this.secTime = sysTime;
      }
      this.lastTime = sysTime;
      this.lastFrameTime = this.lastTime;
      return this.iterations++;
    };

    CircuitSolver.prototype.getStamper = function() {
      return this.Stamper;
    };

    CircuitSolver.prototype.getIterCount = function() {
      var sim_speed;
      sim_speed = this.Circuit.simSpeed();
      return 0.1 * Math.exp((sim_speed - 61.0) / 24.0);
    };

    CircuitSolver.prototype.discoverGroundReference = function() {
      var ce, circuitNode, gotGround, gotRail, l, len, pt, ref, volt;
      gotGround = false;
      gotRail = false;
      volt = null;
      ref = this.Circuit.getElements();
      for (l = 0, len = ref.length; l < len; l++) {
        ce = ref[l];
        if (ce instanceof GroundElm) {
          gotGround = true;
          break;
        }
        if (Util.typeOf(ce, RailElm)) {
          gotRail = true;
        }
        if ((volt == null) && Util.typeOf(ce, VoltageElm)) {
          volt = ce;
        }
      }
      circuitNode = new CircuitNode(this);
      circuitNode.x = circuitNode.y = -1;
      if (!gotGround && !gotRail && (volt != null)) {
        pt = volt.getPost(0);
        circuitNode.x = pt.x;
        circuitNode.y = pt.y;
      }
      return this.Circuit.addCircuitNode(circuitNode);
    };

    CircuitSolver.prototype.buildComponentNodes = function() {
      var circuitElm, circuitNode, internalLink, internalNode, internalNodeCount, internalNodeIdx, internalVSCount, l, len, m, n, nodeIdx, nodeLink, o, postCount, postIdx, postPt, ref, ref1, ref2, ref3, results, voltageSourceCount;
      voltageSourceCount = 0;
      ref = this.Circuit.getElements();
      results = [];
      for (l = 0, len = ref.length; l < len; l++) {
        circuitElm = ref[l];
        internalNodeCount = circuitElm.numInternalNodes();
        internalVSCount = circuitElm.numVoltageSources();
        postCount = circuitElm.numPosts();
        for (postIdx = m = 0, ref1 = postCount; 0 <= ref1 ? m < ref1 : m > ref1; postIdx = 0 <= ref1 ? ++m : --m) {
          postPt = circuitElm.getPost(postIdx);
          for (nodeIdx = n = 0, ref2 = this.Circuit.numNodes(); 0 <= ref2 ? n < ref2 : n > ref2; nodeIdx = 0 <= ref2 ? ++n : --n) {
            circuitNode = this.Circuit.getNode(nodeIdx);
            if (Util.overlappingPoints(postPt, circuitNode)) {
              break;
            }
          }
          nodeLink = new CircuitNodeLink();
          nodeLink.num = postIdx;
          nodeLink.elm = circuitElm;
          if (nodeIdx === this.Circuit.numNodes()) {
            circuitNode = new CircuitNode(this, postPt.x, postPt.y);
            circuitNode.links.push(nodeLink);
            circuitElm.setNode(postIdx, this.Circuit.numNodes());
            this.Circuit.addCircuitNode(circuitNode);
          } else {
            this.Circuit.getNode(nodeIdx).links.push(nodeLink);
            circuitElm.setNode(postIdx, nodeIdx);
            if (nodeIdx === 0) {
              circuitElm.setNodeVoltage(postIdx, 0);
            }
          }
        }
        for (internalNodeIdx = o = 0, ref3 = internalNodeCount; 0 <= ref3 ? o < ref3 : o > ref3; internalNodeIdx = 0 <= ref3 ? ++o : --o) {
          internalLink = new CircuitNodeLink();
          internalLink.num = internalNodeIdx + postCount;
          internalLink.elm = circuitElm;
          internalNode = new CircuitNode(this, -1, -1, true);
          internalNode.links.push(internalLink);
          circuitElm.setNode(internalLink.num, this.Circuit.numNodes());
          this.Circuit.addCircuitNode(internalNode);
        }
        results.push(voltageSourceCount += internalVSCount);
      }
      return results;
    };

    CircuitSolver.prototype.constructCircuitGraph = function() {
      var circuitElement, l, len, m, ref, ref1, voltSourceIdx, voltageSourceCount;
      this.buildComponentNodes();
      this.Circuit.voltageSources = new Array(voltageSourceCount);
      voltageSourceCount = 0;
      this.circuitNonLinear = false;
      ref = this.Circuit.getElements();
      for (l = 0, len = ref.length; l < len; l++) {
        circuitElement = ref[l];
        if (circuitElement.nonLinear()) {
          this.circuitNonLinear = true;
        }
        for (voltSourceIdx = m = 0, ref1 = circuitElement.numVoltageSources(); 0 <= ref1 ? m < ref1 : m > ref1; voltSourceIdx = 0 <= ref1 ? ++m : --m) {
          this.Circuit.voltageSources[voltageSourceCount] = circuitElement;
          circuitElement.setVoltageSource(voltSourceIdx, voltageSourceCount++);
        }
      }
      this.Circuit.voltageSourceCount = voltageSourceCount;
      return this.matrixSize = this.Circuit.numNodes() + voltageSourceCount - 1;
    };

    CircuitSolver.prototype.constructMatrixEquations = function() {
      var circuitElm, l, len, m, ref, ref1, results, rowIdx;
      this.circuitMatrixSize = this.circuitMatrixFullSize = this.matrixSize;
      this.circuitMatrix = Util.zeroArray2(this.matrixSize, this.matrixSize);
      this.origMatrix = Util.zeroArray2(this.matrixSize, this.matrixSize);
      this.circuitRightSide = Util.zeroArray(this.matrixSize);
      this.origRightSide = Util.zeroArray(this.matrixSize);
      this.circuitRowInfo = Util.zeroArray(this.matrixSize);
      this.circuitPermute = Util.zeroArray(this.matrixSize);
      for (rowIdx = l = 0, ref = this.matrixSize; 0 <= ref ? l < ref : l > ref; rowIdx = 0 <= ref ? ++l : --l) {
        this.circuitRowInfo[rowIdx] = new RowInfo();
      }
      this.circuitNeedsMap = false;
      ref1 = this.Circuit.getElements();
      results = [];
      for (m = 0, len = ref1.length; m < len; m++) {
        circuitElm = ref1[m];
        results.push(circuitElm.stamp(this.Stamper));
      }
      return results;
    };

    CircuitSolver.prototype.checkConnectivity = function() {
      var changed, circuitElm, closure, l, len, m, n, nodeIdx, postIdx, ref, ref1, ref2, results, siblingNode, siblingPostIdx;
      closure = new Array(this.Circuit.numNodes());
      closure[0] = true;
      changed = true;
      results = [];
      while (changed) {
        changed = false;
        ref = this.Circuit.getElements();
        for (l = 0, len = ref.length; l < len; l++) {
          circuitElm = ref[l];
          for (postIdx = m = 0, ref1 = circuitElm.numPosts(); 0 <= ref1 ? m < ref1 : m > ref1; postIdx = 0 <= ref1 ? ++m : --m) {
            if (!closure[circuitElm.getNode(postIdx)]) {
              if (circuitElm.hasGroundConnection(postIdx)) {
                changed = true;
                closure[circuitElm.getNode(postIdx)] = true;
              }
              continue;
            }
            for (siblingPostIdx = n = 0, ref2 = circuitElm.numPosts(); 0 <= ref2 ? n < ref2 : n > ref2; siblingPostIdx = 0 <= ref2 ? ++n : --n) {
              if (postIdx === siblingPostIdx) {
                continue;
              }
              siblingNode = circuitElm.getNode(siblingPostIdx);
              if (circuitElm.getConnection(postIdx, siblingPostIdx) && !closure[siblingNode]) {
                closure[siblingNode] = true;
                changed = true;
              }
            }
          }
        }
        if (changed) {
          continue;
        }
        results.push((function() {
          var o, ref3, results1;
          results1 = [];
          for (nodeIdx = o = 0, ref3 = this.Circuit.numNodes(); 0 <= ref3 ? o < ref3 : o > ref3; nodeIdx = 0 <= ref3 ? ++o : --o) {
            if (!closure[nodeIdx] && !this.Circuit.nodeList[nodeIdx].intern) {
              console.warn("Node " + nodeIdx + " unconnected! -> " + (this.Circuit.nodeList[nodeIdx].toString()));
              this.Stamper.stampResistor(0, nodeIdx, 1e8);
              closure[nodeIdx] = true;
              changed = true;
              break;
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    CircuitSolver.prototype.findInvalidPaths = function() {
      var ce, fpi, l, len, pathfinder, ref;
      ref = this.Circuit.getElements();
      for (l = 0, len = ref.length; l < len; l++) {
        ce = ref[l];
        if (ce instanceof InductorElm) {
          fpi = new Pathfinder(Pathfinder.INDUCT, ce, ce.getNode(1), this.Circuit.getElements(), this.Circuit.numNodes());
          if (!fpi.findPath(ce.getNode(0), 5) && !fpi.findPath(ce.getNode(0))) {
            ce.reset();
          }
        }
        if (ce instanceof CurrentElm) {
          fpi = new Pathfinder(Pathfinder.INDUCT, ce, ce.getNode(1), this.Circuit.getElements(), this.Circuit.numNodes());
          if (!fpi.findPath(ce.getNode(0))) {
            console.warn("No path for current source!", ce);
          }
        }
        if ((Util.typeOf(ce, VoltageElm) && ce.numPosts() === 2) || ce instanceof WireElm) {
          pathfinder = new Pathfinder(Pathfinder.VOLTAGE, ce, ce.getNode(1), this.Circuit.getElements(), this.Circuit.numNodes());
          if (pathfinder.findPath(ce.getNode(0))) {
            this.Circuit.halt("Voltage source/wire loop with no resistance!", ce);
          }
        }
        if (ce instanceof CapacitorElm) {
          fpi = new Pathfinder(Pathfinder.SHORT, ce, ce.getNode(1), this.Circuit.getElements(), this.Circuit.numNodes());
          if (fpi.findPath(ce.getNode(0))) {
            ce.reset();
          } else {
            fpi = new Pathfinder(Pathfinder.CAP_V, ce, ce.getNode(1), this.Circuit.getElements(), this.Circuit.numNodes());
            if (fpi.findPath(ce.getNode(0))) {
              console.warn("Capacitor loop with no resistance!", ce);
              return;
            }
          }
        }
      }
    };


    /*
    Apply Sparse Tableau Analysis to reduce dimensionality of circuit equations.
     */

    CircuitSolver.prototype.optimize = function() {
      var circuitRowInfo, col, elt, j, k, l, lastVal, m, n, newIdx, newMatDim, newMatx, newRS, newSize, o, p, q, qm, qp, qq, re, ref, ref1, ref2, ref3, ref4, ref5, row, rowInfo, rowNodeEq, rsadd;
      row = -1;
      while (row < this.matrixSize - 1) {
        row += 1;
        re = this.circuitRowInfo[row];
        if (re.lsChanges || re.dropRow || re.rsChanges) {
          continue;
        }
        rsadd = 0;
        qm = -1;
        qp = -1;
        lastVal = 0;
        for (col = l = 0, ref = this.matrixSize; 0 <= ref ? l < ref : l > ref; col = 0 <= ref ? ++l : --l) {
          if (this.circuitRowInfo[col].type === RowInfo.ROW_CONST) {
            rsadd -= this.circuitRowInfo[col].value * this.circuitMatrix[row][col];
          } else if (this.circuitMatrix[row][col] === 0) {

          } else if (qp === -1) {
            qp = col;
            lastVal = this.circuitMatrix[row][col];
          } else if (qm === -1 && (this.circuitMatrix[row][col] === -lastVal)) {
            qm = col;
          } else {
            break;
          }
        }
        if (col === this.matrixSize) {
          if (qp === -1) {
            this.Circuit.halt("Matrix error qp (row with all zeros) (rsadd = " + rsadd + ")", null);
            return;
          }
          elt = this.circuitRowInfo[qp];
          if (qm === -1) {
            k = 0;
            while (elt.type === RowInfo.ROW_EQUAL && k < CircuitSolver.SIZE_LIMIT) {
              qp = elt.nodeEq;
              elt = this.circuitRowInfo[qp];
              ++k;
            }
            if (elt.type === RowInfo.ROW_EQUAL) {
              elt.type = RowInfo.ROW_NORMAL;
            } else if (elt.type !== RowInfo.ROW_NORMAL) {

            } else {
              elt.type = RowInfo.ROW_CONST;
              elt.value = (this.circuitRightSide[row] + rsadd) / lastVal;
              this.circuitRowInfo[row].dropRow = true;
              row = -1;
            }
          } else if ((this.circuitRightSide[row] + rsadd) === 0) {
            if (elt.type !== RowInfo.ROW_NORMAL) {
              qq = qm;
              qm = qp;
              qp = qq;
              elt = this.circuitRowInfo[qp];
              if (elt.type !== RowInfo.ROW_NORMAL) {
                continue;
              }
            }
            elt.type = RowInfo.ROW_EQUAL;
            elt.nodeEq = qm;
            this.circuitRowInfo[row].dropRow = true;
          }
        }
      }
      newMatDim = 0;
      for (row = m = 0, ref1 = this.matrixSize; 0 <= ref1 ? m < ref1 : m > ref1; row = 0 <= ref1 ? ++m : --m) {
        rowInfo = this.circuitRowInfo[row];
        if (rowInfo.type === RowInfo.ROW_NORMAL) {
          rowInfo.mapCol = newMatDim++;
        } else {
          if (rowInfo.type === RowInfo.ROW_EQUAL) {
            for (j = n = 0, ref2 = CircuitSolver.SIZE_LIMIT; 0 <= ref2 ? n < ref2 : n > ref2; j = 0 <= ref2 ? ++n : --n) {
              rowNodeEq = this.circuitRowInfo[rowInfo.nodeEq];
              if ((rowNodeEq.type !== RowInfo.ROW_EQUAL) || (row === rowNodeEq.nodeEq)) {
                break;
              }
              rowInfo.nodeEq = rowNodeEq.nodeEq;
            }
          }
          if (rowInfo.type === RowInfo.ROW_CONST) {
            rowInfo.mapCol = -1;
          }
        }
      }
      for (row = o = 0, ref3 = this.matrixSize; 0 <= ref3 ? o < ref3 : o > ref3; row = 0 <= ref3 ? ++o : --o) {
        rowInfo = this.circuitRowInfo[row];
        if (rowInfo.type === RowInfo.ROW_EQUAL) {
          rowNodeEq = this.circuitRowInfo[rowInfo.nodeEq];
          if (rowNodeEq.type === RowInfo.ROW_CONST) {
            rowInfo.type = rowNodeEq.type;
            rowInfo.value = rowNodeEq.value;
            rowInfo.mapCol = -1;
          } else {
            rowInfo.mapCol = rowNodeEq.mapCol;
          }
        }
      }
      newSize = newMatDim;
      newMatx = Util.zeroArray2(newSize, newSize);
      newRS = new Array(newSize);
      Util.zeroArray(newRS);
      newIdx = 0;
      for (row = p = 0, ref4 = this.matrixSize; 0 <= ref4 ? p < ref4 : p > ref4; row = 0 <= ref4 ? ++p : --p) {
        circuitRowInfo = this.circuitRowInfo[row];
        if (circuitRowInfo.dropRow) {
          circuitRowInfo.mapRow = -1;
        } else {
          newRS[newIdx] = this.circuitRightSide[row];
          circuitRowInfo.mapRow = newIdx;
          for (col = q = 0, ref5 = this.matrixSize; 0 <= ref5 ? q < ref5 : q > ref5; col = 0 <= ref5 ? ++q : --q) {
            rowInfo = this.circuitRowInfo[col];
            if (rowInfo.type === RowInfo.ROW_CONST) {
              newRS[newIdx] -= rowInfo.value * this.circuitMatrix[row][col];
            } else {
              newMatx[newIdx][rowInfo.mapCol] += this.circuitMatrix[row][col];
            }
          }
          newIdx++;
        }
      }
      this.circuitMatrix = newMatx;
      this.circuitRightSide = newRS;
      this.matrixSize = this.circuitMatrixSize = newSize;
      this.saveOriginalMatrixState();
      this.circuitNeedsMap = true;
      return this.analyzeFlag = false;
    };

    CircuitSolver.prototype.saveOriginalMatrixState = function() {
      var col, l, m, ref, ref1, results, row;
      for (row = l = 0, ref = this.matrixSize; 0 <= ref ? l < ref : l > ref; row = 0 <= ref ? ++l : --l) {
        this.origRightSide[row] = this.circuitRightSide[row];
      }
      if (this.circuitNonLinear) {
        results = [];
        for (row = m = 0, ref1 = this.matrixSize; 0 <= ref1 ? m < ref1 : m > ref1; row = 0 <= ref1 ? ++m : --m) {
          results.push((function() {
            var n, ref2, results1;
            results1 = [];
            for (col = n = 0, ref2 = this.matrixSize; 0 <= ref2 ? n < ref2 : n > ref2; col = 0 <= ref2 ? ++n : --n) {
              results1.push(this.origMatrix[row][col] = this.circuitMatrix[row][col]);
            }
            return results1;
          }).call(this));
        }
        return results;
      }
    };

    CircuitSolver.prototype.restoreOriginalMatrixState = function() {
      var col, l, m, ref, ref1, results, row;
      for (row = l = 0, ref = this.circuitMatrixSize; 0 <= ref ? l < ref : l > ref; row = 0 <= ref ? ++l : --l) {
        this.circuitRightSide[row] = this.origRightSide[row];
      }
      if (this.circuitNonLinear) {
        results = [];
        for (row = m = 0, ref1 = this.circuitMatrixSize; 0 <= ref1 ? m < ref1 : m > ref1; row = 0 <= ref1 ? ++m : --m) {
          results.push((function() {
            var n, ref2, results1;
            results1 = [];
            for (col = n = 0, ref2 = this.circuitMatrixSize; 0 <= ref2 ? n < ref2 : n > ref2; col = 0 <= ref2 ? ++n : --n) {
              results1.push(this.circuitMatrix[row][col] = this.origMatrix[row][col]);
            }
            return results1;
          }).call(this));
        }
        return results;
      }
    };

    CircuitSolver.prototype.getValueFromNode = function(idx) {
      var rowInfo;
      rowInfo = this.circuitRowInfo[idx];
      if (rowInfo.type === RowInfo.ROW_CONST) {
        return rowInfo.value;
      } else {
        return this.circuitRightSide[rowInfo.mapCol];
      }
    };

    CircuitSolver.prototype.updateComponent = function(nodeIdx, value) {
      var circuitNode, circuitNodeLink, ji, l, len, ref;
      if (isNaN(value)) {
        this.converged = false;
        return false;
      }
      if (nodeIdx < (this.Circuit.numNodes() - 1)) {
        circuitNode = this.Circuit.nodeList[nodeIdx + 1];
        ref = circuitNode.links;
        for (l = 0, len = ref.length; l < len; l++) {
          circuitNodeLink = ref[l];
          circuitNodeLink.elm.setNodeVoltage(circuitNodeLink.num, value);
        }
      } else {
        ji = nodeIdx - (this.Circuit.numNodes() - 1);
        this.Circuit.voltageSources[ji].setCurrent(ji, value);
      }
      return true;
    };

    /*
      luFactor: finds a solution to a factored matrix through LU (Lower-Upper) factorization
    
      Called once each frame for resistive circuits, otherwise called many times each frame
    
      returns a falsy value if the provided circuitMatrix can't be factored
    
      @param (input/output) circuitMatrix 2D matrix to be solved
      @param (input) matrixSize number or rows/columns in the matrix
      @param (output) pivotArray pivot index
     */

    CircuitSolver.prototype.luFactor = function(circuitMatrix, matrixSize, pivotArray) {
      var i, j, k, largest, largestRow, matrix_ij, mult, x;
      i = 0;
      while (i < matrixSize) {
        largest = 0;
        j = 0;
        while (j < matrixSize) {
          x = Math.abs(circuitMatrix[i][j]);
          if (x > largest) {
            largest = x;
          }
          ++j;
        }
        this.scaleFactors[i] = 1.0 / largest;
        ++i;
      }
      j = 0;
      while (j < matrixSize) {
        i = 0;
        while (i < j) {
          matrix_ij = circuitMatrix[i][j];
          k = 0;
          while (k !== i) {
            matrix_ij -= circuitMatrix[i][k] * circuitMatrix[k][j];
            ++k;
          }
          circuitMatrix[i][j] = matrix_ij;
          ++i;
        }
        largest = 0;
        largestRow = -1;
        i = j;
        while (i < matrixSize) {
          matrix_ij = circuitMatrix[i][j];
          k = 0;
          while (k < j) {
            matrix_ij -= circuitMatrix[i][k] * circuitMatrix[k][j];
            ++k;
          }
          circuitMatrix[i][j] = matrix_ij;
          x = Math.abs(matrix_ij);
          if (x >= largest) {
            largest = x;
            largestRow = i;
          }
          ++i;
        }
        if (j !== largestRow) {
          k = 0;
          while (k < matrixSize) {
            x = circuitMatrix[largestRow][k];
            circuitMatrix[largestRow][k] = circuitMatrix[j][k];
            circuitMatrix[j][k] = x;
            ++k;
          }
          this.scaleFactors[largestRow] = this.scaleFactors[j];
        }
        pivotArray[j] = largestRow;
        if (circuitMatrix[j][j] === 0) {
          circuitMatrix[j][j] = 1e-18;
        }
        if (j !== matrixSize - 1) {
          mult = 1 / circuitMatrix[j][j];
          i = j + 1;
          while (i !== matrixSize) {
            circuitMatrix[i][j] *= mult;
            ++i;
          }
        }
        ++j;
      }
      return true;
    };


    /*
      Step 2: `lu_solve`: (Called by lu_factor)
      finds a solution to a factored matrix through LU (Lower-Upper) factorization
    
      Called once each frame for resistive circuits, otherwise called many times each frame
    
      @param circuitMatrix matrix to be solved
      @param numRows dimension
      @param pivotVector pivot index
      @param circuitRightSide Right-side (dependent) matrix
     */

    CircuitSolver.prototype.luSolve = function(circuitMatrix, numRows, pivotVector, circuitRightSide) {
      var bi, i, j, results, row, swap, tot, total;
      i = 0;
      while (i < numRows) {
        row = pivotVector[i];
        swap = circuitRightSide[row];
        circuitRightSide[row] = circuitRightSide[i];
        circuitRightSide[i] = swap;
        if (swap !== 0) {
          break;
        }
        ++i;
      }
      bi = i++;
      while (i < numRows) {
        row = pivotVector[i];
        tot = circuitRightSide[row];
        circuitRightSide[row] = circuitRightSide[i];
        j = bi;
        while (j < i) {
          tot -= circuitMatrix[i][j] * circuitRightSide[j];
          ++j;
        }
        circuitRightSide[i] = tot;
        ++i;
      }
      i = numRows - 1;
      results = [];
      while (i >= 0) {
        total = circuitRightSide[i];
        j = i + 1;
        while (j !== numRows) {
          total -= circuitMatrix[i][j] * circuitRightSide[j];
          ++j;
        }
        circuitRightSide[i] = total / circuitMatrix[i][i];
        results.push(i--);
      }
      return results;
    };

    CircuitSolver.prototype.dump = function() {
      var l, len, out, ref, rowInfo;
      out = "";
      out += this.Circuit.Params.toString() + "\n";
      ref = this.circuitRowInfo;
      for (l = 0, len = ref.length; l < len; l++) {
        rowInfo = ref[l];
        out += rowInfo.toString() + "\n";
      }
      out += "\nCircuit permute: " + Util.printArray(this.circuitPermute);
      return out + "\n";
    };

    CircuitSolver.prototype.dumpOrigFrame = function() {
      var circuitMatrixDump, circuitRightSideDump, i, j, l, m, matrixRowCount, out, ref, ref1;
      matrixRowCount = this.origRightSide.length;
      circuitMatrixDump = "";
      circuitRightSideDump = "  RS: [";
      for (i = l = 0, ref = matrixRowCount; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        circuitRightSideDump += Util.tidyFloat(this.origRightSide[i]);
        circuitMatrixDump += "  [";
        for (j = m = 0, ref1 = matrixRowCount; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
          circuitMatrixDump += Util.tidyFloat(this.origMatrix[i][j]);
          if (j !== matrixRowCount - 1) {
            circuitMatrixDump += ", ";
          }
        }
        circuitMatrixDump += "]\n";
        if (i !== matrixRowCount - 1) {
          circuitRightSideDump += ", ";
        }
      }
      out = "";
      out += circuitMatrixDump + "\n";
      out += circuitRightSideDump + "]";
      return out;
    };

    CircuitSolver.prototype.dumpFrame = function() {
      var circuitMatrixDump, circuitRightSideDump, i, j, l, m, matrixRowCount, out, ref, ref1;
      matrixRowCount = this.circuitRightSide.length;
      if (!this.circuitMatrix || !!this.circuitMatrix[0]) {
        return "";
      }
      circuitMatrixDump = "";
      circuitRightSideDump = "  RS: [";
      for (i = l = 0, ref = matrixRowCount; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        circuitRightSideDump += Util.tidyFloat(this.circuitRightSide[i]);
        circuitMatrixDump += "  [";
        for (j = m = 0, ref1 = matrixRowCount; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
          circuitMatrixDump += Util.tidyFloat(this.circuitMatrix[i][j]);
          if (j !== matrixRowCount - 1) {
            circuitMatrixDump += ", ";
          }
        }
        circuitMatrixDump += "]\n";
        if (i !== matrixRowCount - 1) {
          circuitRightSideDump += ", ";
        }
      }
      out = "";
      out += "  iter: " + this.Circuit.iterations + ", time: " + (this.Circuit.time.toFixed(7)) + ", subiter: " + this.subIterations + " rows: " + matrixRowCount + "\n";
      out += circuitMatrixDump + "\n";
      out += circuitRightSideDump + "]";
      return out;
    };

    return CircuitSolver;

  })();

  module.exports = CircuitSolver;

}).call(this);
