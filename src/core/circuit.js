// Generated by CoffeeScript 1.4.0
(function() {

  define(['cs!KeyboardState', 'cs!Oscilloscope', 'cs!Logger', 'cs!ColorMapState', 'cs!CircuitState', 'cs!CircuitRenderer', 'cs!Point', 'cs!Rectangle', 'cs!Polygon', 'cs!Grid', 'cs!CircuitEngineParams', 'cs!MouseState', 'cs!Settings', 'cs!ComponentRegistry', 'cs!Hint', 'cs!CommandHistory', 'cs!CircuitSolver', 'cs!Units'], function(KeyboardState, Oscilloscope, Logger, ColorMapState, CircuitState, CircuitRenderer, Point, Rectangle, Polygon, Grid, CircuitEngineParams, MouseState, Settings, ComponentRegistry, Hint, CommandHistory, CircuitSolver, Units) {
    var Circuit;
    Circuit = (function() {

      function Circuit(CanvasElm) {
        this.Params = new CircuitEngineParams();
        this.CommandHistory = new CommandHistory();
        this.Renderer = new CircuitRenderer(this, CanvasElm);
        this.clearAndReset();
      }

      Circuit.prototype.setParamsFromJSON = function(jsonData) {
        return this.Params = new CircuitEngineParams(jsonData);
      };

      /*
            Removes all circuit elements and scopes from the workspace and resets time to zero.
      */


      Circuit.prototype.clearAndReset = function() {
        var element, _i, _len, _ref;
        _ref = this.elementList != null;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          element = _ref[_i];
          element.destroy();
        }
        this.grid = new Grid();
        this.nodeList = [];
        this.elementList = [];
        this.voltageSources = [];
        this.Solver = new CircuitSolver(this);
        this.time = 0;
        this.lastTime = 0;
        this.Hint = new Hint(this);
        this.mouseState = new MouseState();
        this.keyboardState = new KeyboardState();
        this.colorMapState = new ColorMapState();
        this.state = CircuitState.RUNNING;
        this.clearErrors();
        this.scopes = [];
        return this.scopeColCount = [];
      };

      Circuit.prototype.setupScopes = function() {};

      Circuit.prototype.getRenderer = function() {
        return this.Renderer;
      };

      Circuit.prototype.solder = function(newElement) {
        newElement.setParentCircuit(this);
        newElement.setPoints();
        console.log("Soldering Element: " + newElement);
        return this.elementList.push(newElement);
      };

      Circuit.prototype.desolder = function(oldElement, destroy) {
        if (destroy == null) {
          destroy = true;
        }
        oldElement.Circuit = null;
        this.elementList.remove(oldElement);
        return oldElement.destroy();
      };

      Circuit.prototype.getVoltageSources = function() {
        return this.voltageSources;
      };

      Circuit.prototype.getElements = function() {
        return this.elementList;
      };

      Circuit.prototype.findElm = function(searchElm) {
        var circuitElm, _i, _len, _ref;
        _ref = this.elementList;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          circuitElm = _ref[_i];
          if (searchElm === circuitElm) {
            return circuitElm;
          }
        }
        return false;
      };

      Circuit.prototype.getElmByIdx = function(elmIdx) {
        return this.elementList[elmIdx];
      };

      Circuit.prototype.numElements = function() {
        return this.elementList.length;
      };

      Circuit.prototype.getScopes = function() {
        return [];
      };

      Circuit.prototype.resetNodes = function() {
        return this.nodeList = [];
      };

      Circuit.prototype.addCircuitNode = function(circuitNode) {
        return this.nodeList.push(circuitNode);
      };

      Circuit.prototype.getNode = function(idx) {
        return this.nodeList[idx];
      };

      Circuit.prototype.getNodes = function() {
        return this.nodeList;
      };

      Circuit.prototype.numNodes = function() {
        return this.nodeList.length;
      };

      Circuit.prototype.getGrid = function() {
        return this.grid;
      };

      /*
            UpdateCircuit:
      
             Updates the circuit each frame.
      
              1. ) Reconstruct Circuit:
                    Rebuilds a data representation of the circuit (only applied when circuit changes)
              2. ) Solve Circuit build matrix representation of the circuit solve for the voltage and current for each component.
                    Solving is performed via LU factorization.
      */


      Circuit.prototype.updateCircuit = function(frameTime) {
        var endTime, startTime;
        this.Renderer.clear();
        startTime = (new Date()).getTime();
        this.Solver.reconstruct();
        if (!this.Solver.isStopped) {
          this.Solver.solveCircuit();
          this.lastTime = this.updateTimings();
        } else {
          this.lastTime = 0;
        }
        this.renderCircuit();
        this.renderScopes();
        this.renderInfo();
        endTime = (new Date()).getTime();
        frameTime = endTime - startTime;
        return this.lastFrameTime = this.lastTime;
      };

      /*
            Clears current states, graphs, and errors then Restarts the circuit from time zero.
      */


      Circuit.prototype.restartAndStop = function() {
        this.restartAndRun();
        this.simulation = cancelAnimationFrame();
        return this.Solver.stop("Restarted Circuit from time 0");
      };

      Circuit.prototype.restartAndRun = function() {
        var element, scope, _i, _j, _len, _len1, _ref, _ref1;
        if (!this.Solver) {
          halt("Solver not initialized!");
        }
        _ref = this.elementList;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          element = _ref[_i];
          element.reset();
        }
        _ref1 = this.scopes;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          scope = _ref1[_j];
          scope.resetGraph();
        }
        return this.Solver.reset();
      };

      Circuit.prototype.getCircuitBottom = function() {
        var bottom, element, rect, _i, _len, _ref;
        if (this.circuitBottom) {
          return this.circuitBottom;
        }
        _ref = this.elementList;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          element = _ref[_i];
          rect = element.boundingBox;
          bottom = rect.height + rect.y;
          if (bottom > this.circuitBottom) {
            this.circuitBottom = bottom;
          }
        }
        return this.circuitBottom;
      };

      Circuit.prototype.updateTimings = function() {
        var currentSpeed, inc, sysTime;
        sysTime = (new Date()).getTime();
        inc = Math.floor(sysTime - this.lastTime);
        currentSpeed = Math.exp(this.Params.currentSpeed / 3.5 - 14.2);
        this.Params.currentMult = 1.7 * inc * currentSpeed;
        if ((sysTime - this.secTime) >= 1000) {
          this.framerate = this.frames;
          this.steprate = this.Solver.steps;
          this.frames = 0;
          this.steps = 0;
          this.secTime = sysTime;
        }
        this.frames++;
        return sysTime;
      };

      Circuit.prototype.renderCircuit = function() {
        var circuitElm, tempMouseMode, _i, _j, _len, _len1, _ref, _ref1, _results;
        this.powerMult = Math.exp(this.Params.powerRange / 4.762 - 7);
        _ref = this.elementList;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          circuitElm = _ref[_i];
          this.Renderer.drawComponent(circuitElm);
        }
        tempMouseMode = this.mouseState.tempMouseMode;
        if (tempMouseMode === MouseState.MODE_DRAG_ROW || tempMouseMode === MouseState.MODE_DRAG_COLUMN || tempMouseMode === MouseState.MODE_DRAG_POST || tempMouseMode === MouseState.MODE_DRAG_SELECTED) {
          _ref1 = this.elementList;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            circuitElm = _ref1[_j];
            circuitElm.drawPost(circuitElm.x1, circuitElm.y1);
            _results.push(circuitElm.drawPost(circuitElm.x2, circuitElm.y2));
          }
          return _results;
        }
      };

      Circuit.prototype.renderScopes = function() {};

      Circuit.prototype.renderInfo = function() {
        var hint, info, realMouseElm;
        realMouseElm = this.mouseElm;
        if (this.mouseElm == null) {
          this.mouseElm = this.stopElm;
        }
        if (this.stopMessage != null) {
          return this.halt(this.stopMessage);
        } else {
          if (this.circuitBottom === 0) {
            this.getCircuitBottom();
          }
          info = [];
          if (this.mouseElm != null) {
            if (this.mousePost === -1) {
              this.mouseElm.getInfo(info);
            } else {
              info.push("V = " + Units.getUnitText(this.mouseElm.getPostVoltage(this.mousePost), "V"));
            }
          } else {
            Settings.fractionalDigits = 2;
            info.push("t = " + Units.getUnitText(this.Solver.time, "s") + "\nft: " + (this.lastTime - this.lastFrameTime) + "\n");
          }
          if (this.Hint.hintType !== -1) {
            hint = this.Hint.getHint();
            if (!hint) {
              this.Hint.hintType = -1;
            } else {
              info.push(hint);
            }
          }
          this.Renderer.drawInfo(info);
          return this.mouseElm = realMouseElm;
        }
      };

      Circuit.prototype.findBadNodes = function() {
        var badNodes, circuitElm, circuitNode, firstCircuitNode, numBadPoints, _i, _j, _len, _len1, _ref, _ref1;
        badNodes = [];
        _ref = this.nodeList;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          circuitNode = _ref[_i];
          if (!circuitNode.intern && circuitNode.links.length === 1) {
            numBadPoints = 0;
            firstCircuitNode = circuitNode.links[0];
            _ref1 = this.elementList;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              circuitElm = _ref1[_j];
              console.log("Compare: " + (firstCircuitNode.elm.toString()) + "  " + (circuitElm.toString()));
              if (firstCircuitNode.elm.toString() !== circuitElm.toString() && circuitElm.boundingBox.contains(circuitNode.x, circuitNode.y)) {
                numBadPoints++;
              }
            }
            if (numBadPoints > 0) {
              badNodes.push(circuitNode);
            }
          }
        }
        return badNodes;
      };

      Circuit.prototype.warn = function(message) {
        Logger.warn(message);
        return this.warnMessage = message;
      };

      Circuit.prototype.halt = function(message) {
        Logger.error(message);
        return this.stopMessage = message;
      };

      Circuit.prototype.clearErrors = function() {
        this.stopMessage = null;
        return this.stopElm = null;
      };

      /*
            Delegations:
      */


      Circuit.prototype.isStopped = function() {
        return this.Solver.isStopped;
      };

      Circuit.prototype.doDots = function() {
        return true;
      };

      Circuit.prototype.voltageRange = function() {
        return this.Params['voltageRange'];
      };

      Circuit.prototype.powerRange = function() {
        return this.Params['powerRange'];
      };

      Circuit.prototype.currentSpeed = function() {
        return this.Params['currentMult'];
      };

      Circuit.prototype.getState = function() {
        return this.state;
      };

      return Circuit;

    })();
    return Circuit;
  });

}).call(this);
